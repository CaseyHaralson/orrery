## 2. Repository Layout

We organize the repository to separate canonical knowledge (skills, policies, schemas) from tool-specific adapters. Below is a proposed top-level layout with key folders:

```graphql
project-root/
├── agent/
│   ├── skills/
│   │   ├── intake/
│   │   │   └── SKILL.md
│   │   ├── plan/
│   │   │   └── SKILL.md
│   │   ├── execute/
│   │   │   └── SKILL.md
│   │   ├── verify/
│   │   │   └── SKILL.md
│   │   ├── report/
│   │   │   └── SKILL.md
│   │   ├── review/
│   │   │   └── SKILL.md
│   │   └── security/
│   │       └── SKILL.md
│   ├── policies/
│   │   └── WORKFLOW.md      # defines the 5-step protocol, roles, etc.
│   └── schemas/
│       ├── plan-schema.json
│       └── report-schema.json
├── .gemini/
│   ├── settings.json        # Gemini CLI project settings (if needed)
│   ├── GEMINI.md            # Project-wide context instructions (if any)
│   └── skills/              # Materialized skill files for Gemini (auto-synced)
│       └── * (mirrors agent/skills structure) *
├── .claude/
│   ├── settings.json        # Claude Code project settings (permissions, etc.)
│   ├── CLAUDE.md            # Project instructions for Claude (if needed)
│   └── skills/              # Skills for Claude Code (mirrors agent/skills)
│       └── * (same skill subfolders) *
├── .cursor/
│   ├── rules/               # Cursor static rules (if used, e.g., RULE.md)
│   ├── skills/              # Skills for Cursor (mirrors agent/skills)
│   │   └── * (skill subfolders copied or symlinked here) *
│   └── hooks.json           # (Optional) Cursor hooks configuration
├── .codex/
│   └── skills/              # Skills for OpenAI Codex or CLI (mirrors agent/skills)
└── .antigravity/
    └── skills/              # Skills for Google Antigravity (mirrors agent/skills)
```

### Canonical Directories:

  - agent/skills/ – The source of truth for all agent skills. Each skill has its own subdirectory named after the skill (e.g. intake, plan). Inside is a SKILL.md that contains the skill’s instructions and optional YAML frontmatter (more on format below). Additional optional subdirs can provide scripts or reference docs for that skill (e.g. scripts/, references/). For example, a security skill might have a scripts/audit.py to run security scans, referenced in its SKILL.md.

  - agent/policies/WORKFLOW.md – A human-readable canonical definition of the overall workflow protocol and policies that all agents must follow. This document details each phase (intake, plan, execute, verify, report), the expected behavior in that phase, and any general guidelines (e.g. coding style, safety rules). It serves as a single reference for the “rules of engagement” that the agents are following. Agents may not directly read this file, but it’s useful for developers to maintain consistency and could be partially integrated into skill instructions (for instance, the plan/SKILL.md might summarize relevant parts of the protocol).

  - agent/schemas/ – JSON or YAML schemas defining structured formats used by the agents to communicate. Specifically:

    - plan-schema.json (or .yaml): defines the schema for the plan format used in agent-to-agent handoff (task list, dependencies, etc).

    - report-schema.json: defines the schema for an execution report produced after the Execute/Verify phases. Using explicit schemas helps validate that plans and reports are well-formed and allows different agents or tools to parse them consistently.

  - (Optional) agent/benchmarks/ – A suite of standardized tasks and expected outputs for consistency testing (discussed more in section 8). This could include sample prompts and the ideal plan or solution that all agents should achieve, used for regression testing.

### Tool-Specific Directories:

Each AI tool may require its own config directory (commonly a hidden folder like .toolname/) to integrate with the repository. These hold any settings or files that the tool uses at runtime:

  - .gemini/ – For Google Gemini CLI:

    - We include settings.json to configure project-specific settings (e.g. permission policies, enabling experimental features). For instance, setting "experimental.skills": true in this file would turn on the Agent Skills feature in Gemini CLI.

    - GEMINI.md: While not strictly required, Gemini CLI supports hierarchical “context files” named GEMINI.md that are automatically loaded as part of the system prompt. We could use this to provide high-level project instructions or style guidelines that apply to all tasks (though major instructions are better structured into skills). The presence of a GEMINI.md in the repo root or .gemini/ is discovered by Gemini CLI and concatenated into the prompt context.

    - .gemini/skills/: a mirror of the canonical agent/skills. On project setup or update, a sync tool will populate this with each skill’s files (either copying or symlinking from agent/skills). This allows Gemini CLI to discover available skills. (In the future, Gemini CLI may support directly pointing to a skills directory; until then, this folder ensures skills are in the expected location).

  - .claude/ – For Anthropic Claude Code:

    - settings.json for Claude’s project configurations (e.g., allowed/denied tools, environment variables). We might configure this to always allow certain safe operations (like read access to the skills files) and to integrate with our plan files.

    - CLAUDE.md: Claude Code automatically loads a file by this name at startup as persistent instructions. We can use CLAUDE.md to reference our workflow (e.g., “Always follow the 5-step workflow defined by the team. Use the skills available in .claude/skills as needed.”). It is recommended to keep this file concise and focused since it contributes to every prompt’s context.

    - .claude/skills/: again a mirror of the canonical skills, for Claude’s use. If Claude Code supports the Agent Skills open format (Anthropic introduced the standard), it likely looks in .claude/skills/ for skill folders. The sync process will ensure our agent/skills/* appear here. Claude Code’s “subagent” system (custom assistants defined in .claude/agents/) might also be leveraged, but since we want consistency across tools, using the shared skill format is preferable.

  - .cursor/ – For Cursor (AI Editor):

    - Cursor supports two concepts: Rules (static instructions always included) and Skills (dynamic, agent-invoked capabilities). We will store any always-on guidance (if needed) as rules in .cursor/rules/ (each with a RULE.md), analogous to CLAUDE.md/GEMINI.md but segmented by topic if needed. For example, a commands rule might list common commands, a style rule the code style guidelines, etc.

    - .cursor/skills/: Cursor’s implementation of Agent Skills will use a skills directory. We mirror our canonical skills here so that Cursor’s agent can load them dynamically. According to Cursor’s documentation, skills in Cursor are defined by SKILL.md files and can include “Custom commands, Hooks, and Domain instructions”. By having identical SKILL.md files here, the Cursor agent can discover and invoke them when relevant, just like Claude or Gemini.

    - Additionally, Cursor uses a hooks.json for custom automation (not directly our focus, but we might include one to automate plan execution loops if needed as an advanced feature).

  - .codex/ – For OpenAI Codex (or GPT-based code agents):

    - OpenAI’s Codex (or GPT-4/ChatGPT in coding mode) doesn’t natively have a filesystem agent interface like Claude or Gemini. However, we can still adapt. This directory can hold skills for any tool or wrapper that uses OpenAI models. For example, if using a CLI or editor plugin that integrates GPT-4, we could have it read from .codex/skills/ or manually inject those skill instructions via prompts. If using a community tool (like SkillPort or similar) that brings skills to Codex, it could be configured to use this folder. In absence of native support, .codex/skills serves as a staging area for skills that a middleware script can feed into the OpenAI agent’s context.

  - .antigravity/ – For Google Antigravity IDE:

    - Antigravity is an “agent-first” IDE that likely supports shared workflows and skills. We anticipate it will allow loading custom skills (especially since it supports multi-agent orchestration). This folder mirrors the skills for Antigravity’s agent manager to load. If Antigravity uses a similar mechanism to rules/skills (the StackOverflow link hint suggests it can customize rules/workflows in a manner akin to CLAUDE.md), we would store those here. For instance, if Antigravity recognizes a file like AGENT.md or similar for project instructions, we’d include it. For now, .antigravity/skills/ ensures any on-disk skill discovery is satisfied.

### Plan & Task Artifacts:

  - We may also designate a location for plans and reports to be stored for handoff. For example, a plans/ directory in the repo where an agent saves current_plan.yaml (which another agent can read and execute), and a reports/ directory for final reports or intermediate results (screenshots, test outputs etc.). These could alternatively live in a temp folder or be exchanged via memory, but having them in the repo can aid traceability and debugging (and allow humans to inspect). The repository layout should clarify where such artifacts go, perhaps in a git-ignored agent/artifacts/ folder or similar.

By structuring the repository in this way, we ensure a clear separation of concerns:

  - The agent/ folder is the single source of truth for how agents should behave (skills and policies).

  - The dot-folders (.gemini, .claude, etc.) adapt that truth to each specific tool environment, without forking the logic. If a skill is updated in agent/skills/..., a synchronization step updates it for all tool directories, so consistency is maintained.

This layout is platform-agnostic and does not assume any particular CI/CD, though we include hooks for CI and testing. It’s also designed to work offline: all necessary instructions reside in the repo so agents don’t need external internet access (except when the task at hand intentionally uses a tool to fetch something).

Next, we dive deeper into how the skills are defined and used within this architecture.