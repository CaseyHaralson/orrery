## 1. Executive Summary & Recommended Architecture

We propose a unified, repository-based system that ensures multiple coding AI agents (Gemini CLI, Claude Code, OpenAI Codex, Cursor, and Google Antigravity) follow a consistent workflow and can seamlessly collaborate on software tasks. The core idea is to define canonical “agent skills” and a shared workflow protocol in one repository, then synchronize these across tool-specific configurations. Each agent will load the same skills and adhere to the same 5-phase workflow (Intake → Plan → Execute → Verify → Report), enabling coherent behavior regardless of the underlying AI tool.

Recommended Architecture: At the heart of the system is a “Skills” library in the repository that uses the open Agent Skills format. Each skill (e.g. intake, plan, execute, etc.) is a folder containing a standardized SKILL.md with instructions (and optionally scripts or reference files) describing how to perform that phase of work. On project startup, each agent scans the repository’s skills and loads a summary of available skills into its system context (using a concise metadata listing). When an agent needs to perform a phase (like planning or code execution), it “activates” the corresponding skill by pulling in the full instructions from SKILL.md on demand

. This ensures all agents follow the same playbook for each task phase. A shared Plan format (machine- and human-readable) is used for agent-to-agent handoff: one agent can produce a structured plan of action items that another agent (or instance) can parse and execute. A designated Coordinator agent can oversee this process, delegating plan steps to Worker agents and tracking progress.

This architecture is tool-agnostic and maintainable. All core skills, workflow definitions, and policies live in the repository (under version control), and lightweight adapters or configuration files in each tool’s environment (e.g. .claude/, .gemini/, etc.) ensure the tools ingest those skills and follow the protocol. By centralizing skills and workflow logic, teams can update behavior in one place and have all agents immediately use the new approach. It also enables agent-to-agent handoff – for example, an agent using Claude might generate a plan that a Gemini agent can continue executing – since both understand the same plan schema and skill definitions.

In summary, the system creates a unified “multi-agent operating manual” in the repository. This fosters consistent behavior across AI coding tools, allows complex tasks to be split among specialized agents, and provides maintainability via Git versioning and CI testing. Below, we detail the design of the skills architecture, repository layout, workflow protocol, plan schema, tool-specific considerations, synchronization approach, evaluation framework, and governance model, with examples illustrating each part.